//////////////////////////////////////////////////////////////////////////////////////////////
/// \file NoiseModel.hpp
///
/// \author Sean Anderson, ASRL
//////////////////////////////////////////////////////////////////////////////////////////////

#include <steam/NoiseModel.hpp>

#include <iostream>
#include <stdexcept>

#include <Eigen/Cholesky>

namespace steam {

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Default constructor
//////////////////////////////////////////////////////////////////////////////////////////////
NoiseModel::NoiseModel() {
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief General constructor
//////////////////////////////////////////////////////////////////////////////////////////////
NoiseModel::NoiseModel(const Eigen::MatrixXd& matrix, MatrixType type) {

  // Depending on the type of 'matrix', we set the internal storage
  switch(type) {
    case COVARIANCE :
      setByCovariance(matrix);
      break;
    case INFORMATION :
      setByInformation(matrix);
      break;
    case SQRT_INFORMATION :
      setBySqrtInformation(matrix);
      break;
  }
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Set by covariance matrix
//////////////////////////////////////////////////////////////////////////////////////////////
void NoiseModel::setByCovariance(const Eigen::MatrixXd& matrix) {

  // Information is the inverse of covariance
  this->setByInformation(matrix.inverse());
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Set by information matrix
//////////////////////////////////////////////////////////////////////////////////////////////
void NoiseModel::setByInformation(const Eigen::MatrixXd& matrix) {

  // Check that the matrix is positive definite
  this->assertPositiveDefiniteMatrix(matrix);

  // Perform an LLT decomposition
  Eigen::LLT<Eigen::MatrixXd> lltOfInformation(matrix);

  // Store upper triangular matrix (the square root information matrix)
  this->setBySqrtInformation(lltOfInformation.matrixL().transpose());
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Set by square root of information matrix
//////////////////////////////////////////////////////////////////////////////////////////////
void NoiseModel::setBySqrtInformation(const Eigen::MatrixXd& matrix) {
  // Set internal storage matrix
  sqrtInformation_ = matrix; // todo: check this is upper triangular
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Get a reference to the square root information matrix
//////////////////////////////////////////////////////////////////////////////////////////////
const Eigen::MatrixXd& NoiseModel::getSqrtInformation() const {
  return sqrtInformation_;
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Get the norm of the whitened error vector, sqrt(rawError^T * info * rawError)
//////////////////////////////////////////////////////////////////////////////////////////////
double NoiseModel::getWhitenedErrorNorm(const Eigen::VectorXd& rawError) const {
  return (sqrtInformation_*rawError).norm();
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Get the whitened error vector, sqrtInformation*rawError
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::VectorXd NoiseModel::whitenError(const Eigen::VectorXd &rawError) const {
  return sqrtInformation_*rawError;
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Assert that the matrix is positive definite
//////////////////////////////////////////////////////////////////////////////////////////////
void NoiseModel::assertPositiveDefiniteMatrix(const Eigen::MatrixXd& matrix) {

  // Initialize an eigen value solver
  Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> eigsolver(matrix, Eigen::EigenvaluesOnly);

  // Check the minimum eigen value
  if (eigsolver.eigenvalues().minCoeff() <= 0) {
    std::stringstream ss; ss << "Covariance must be positive definite. "
                             << "Min. eigenvalue : " << eigsolver.eigenvalues().minCoeff();
    throw std::invalid_argument(ss.str());
  }
}

} // steam
