//////////////////////////////////////////////////////////////////////////////////////////////
/// \file BlockVector.cpp
///
/// \author Sean Anderson, ASRL
//////////////////////////////////////////////////////////////////////////////////////////////

#include <steam/sparse/BlockVector.hpp>

#include <stdexcept>

namespace steam {

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Default constructor, vector size must still be set before using
//////////////////////////////////////////////////////////////////////////////////////////////
BlockVector::BlockVector() {}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Block size constructor
//////////////////////////////////////////////////////////////////////////////////////////////
BlockVector::BlockVector(const std::vector<unsigned int>& blkRowSizes) {
  this->reset(blkRowSizes);
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Block size (with data) constructor
//////////////////////////////////////////////////////////////////////////////////////////////
BlockVector::BlockVector(const std::vector<unsigned int>& blkRowSizes, const Eigen::VectorXd& v) {
  this->reset(blkRowSizes);
  this->set(v);
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Resize and clear vector
//////////////////////////////////////////////////////////////////////////////////////////////
void BlockVector::reset(const std::vector<unsigned int>& blkRowSizes) {

  if (blkRowSizes.size() <= 0) {
    throw std::invalid_argument("Tried to initialize a block matrix with 0 rows.");
  }

  scalarRowDim_ = 0;
  blkRowSizes_ = blkRowSizes;
  cumBlkRowSizes_.reserve(blkRowSizes_.size());
  for (std::vector<unsigned int>::const_iterator it = blkRowSizes_.begin(); it != blkRowSizes_.end(); ++it) {

    if (*it <= 0) {
      throw std::invalid_argument("Tried to initialize a block row size of 0.");
    }

    cumBlkRowSizes_.push_back(scalarRowDim_);
    scalarRowDim_ += *it;
  }
  data_ = Eigen::VectorXd::Zero(scalarRowDim_);
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Set internal data (total size of v must match concatenated block sizes)
//////////////////////////////////////////////////////////////////////////////////////////////
void BlockVector::set(const Eigen::VectorXd& v) {

  if (scalarRowDim_ != (unsigned int)v.size()) {
    std::stringstream ss; ss << "Block row size: " << scalarRowDim_ <<
                                " and vector size: " << v.size() << " do not match.";
    throw std::invalid_argument(ss.str());
  }

  data_ = v;
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Get number of block rows
//////////////////////////////////////////////////////////////////////////////////////////////
unsigned int BlockVector::getNumBlkRows() {
  return blkRowSizes_.size();
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Adds the vector to the block entry at index 'r', block dim must match
//////////////////////////////////////////////////////////////////////////////////////////////
void BlockVector::add(const unsigned int& r, const Eigen::VectorXd& v) {

  if (r >= blkRowSizes_.size()) {
    throw std::invalid_argument("Requested row index is out of bounds.");
  }

  if (v.rows() != (int)blkRowSizes_[r]) {
    throw std::invalid_argument("Block row size and vector size do not match.");
  }

  data_.block(cumBlkRowSizes_[r],0,blkRowSizes_[r],1) += v;
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Return block vector at index 'r'
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::VectorXd BlockVector::getBlkVector(const unsigned int& r) {

  if (r >= blkRowSizes_.size()) {
    throw std::invalid_argument("Requested row index is out of bounds.");
  }

  return data_.block(cumBlkRowSizes_[r],0,blkRowSizes_[r],1);
}

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Convert to Eigen dense vector format
//////////////////////////////////////////////////////////////////////////////////////////////
Eigen::VectorXd BlockVector::toEigen() {
  return data_;
}

} // steam
