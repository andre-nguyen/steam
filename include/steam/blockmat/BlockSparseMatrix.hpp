//////////////////////////////////////////////////////////////////////////////////////////////
/// \file BlockSparseMatrix.hpp
///
/// \author Sean Anderson, ASRL
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef STEAM_BLOCK_SPARSE_MATRIX_HPP
#define STEAM_BLOCK_SPARSE_MATRIX_HPP

#include <vector>
#include <map>

#include <omp.h>

#include <Eigen/Core>
#include <Eigen/Sparse>

#include <steam/blockmat/BlockMatrixBase.hpp>

namespace steam {

/////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Class to store a block-sparse matrix
/////////////////////////////////////////////////////////////////////////////////////////////
class BlockSparseMatrix : public BlockMatrixBase
{
 public:

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Row entry
  //////////////////////////////////////////////////////////////////////////////////////////////
  class BlockRowEntry
  {
   public:

    ////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Default constructor
    ////////////////////////////////////////////////////////////////////////////////////////////
    BlockRowEntry() {
      omp_init_lock(&lock);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Default destructor
    ////////////////////////////////////////////////////////////////////////////////////////////
    ~BlockRowEntry() {
      omp_destroy_lock(&lock);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Row entry
    ////////////////////////////////////////////////////////////////////////////////////////////
    Eigen::MatrixXd data;

    ////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief OpenMP lock (for multithread)
    ////////////////////////////////////////////////////////////////////////////////////////////
    omp_lock_t lock;
  };

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Default constructor, matrix size must still be set before using
  //////////////////////////////////////////////////////////////////////////////////////////////
  BlockSparseMatrix();

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Rectangular matrix constructor
  //////////////////////////////////////////////////////////////////////////////////////////////
  BlockSparseMatrix(const std::vector<unsigned int>& blkRowSizes,
                    const std::vector<unsigned int>& blkColSizes);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Block-size-symmetric matrix constructor, pure scalar symmetry is still optional
  //////////////////////////////////////////////////////////////////////////////////////////////
  BlockSparseMatrix(const std::vector<unsigned int>& blkSizes, bool symmetric = false);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Clear sparse entries, maintain size
  //////////////////////////////////////////////////////////////////////////////////////////////
  void clear();

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Keep the existing entries and sizes, but set them to zero
  //////////////////////////////////////////////////////////////////////////////////////////////
  virtual void zero();

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Adds the matrix to the block entry at index (r,c), block dim must match
  //////////////////////////////////////////////////////////////////////////////////////////////
  virtual void add(unsigned int r, unsigned int c, const Eigen::MatrixXd& m);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Returns a reference to the row entry at (r,c), if it exists; if it does not exist
  ///        it will be inserted if 'allowInsert' is set to true.
  ///        *Note this throws an exception if matrix is symmetric and you request a lower
  ///         triangular entry.
  //////////////////////////////////////////////////////////////////////////////////////////////
  BlockRowEntry& rowEntryAt(unsigned int r, unsigned int c, bool allowInsert = false);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Returns a reference to the value at (r,c), if it exists
  ///        *Note this throws an exception if matrix is symmetric and you request a lower
  ///         triangular entry. For read operations, use copyAt(r,c).
  //////////////////////////////////////////////////////////////////////////////////////////////
  virtual Eigen::MatrixXd& at(unsigned int r, unsigned int c);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Returns a copy of the entry at index (r,c)
  //////////////////////////////////////////////////////////////////////////////////////////////
  virtual Eigen::MatrixXd copyAt(unsigned int r, unsigned int c) const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Convert to Eigen sparse matrix format
  //////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::SparseMatrix<double> toEigen(bool getSubBlockSparsity = false) const;

 private:

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Gets the number of non-zero entries per scalar-column
  //////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::VectorXi getNnzPerCol() const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Private column structure (holds a list of row entries)
  //////////////////////////////////////////////////////////////////////////////////////////////
  class BlockSparseColumn
  {
   public:

    ////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Default constructor
    ////////////////////////////////////////////////////////////////////////////////////////////
    BlockSparseColumn() {
      omp_init_lock(&lock);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Default destructor
    ////////////////////////////////////////////////////////////////////////////////////////////
    ~BlockSparseColumn() {
      omp_destroy_lock(&lock);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief Row entries
    ////////////////////////////////////////////////////////////////////////////////////////////
    std::map<unsigned int, BlockRowEntry> rows;

    ////////////////////////////////////////////////////////////////////////////////////////////
    /// \brief OpenMP lock (for multithread)
    ////////////////////////////////////////////////////////////////////////////////////////////
    omp_lock_t lock;
  };

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Vector of columns (the data container)
  //////////////////////////////////////////////////////////////////////////////////////////////
  std::vector<BlockSparseColumn> cols_;
};

} // steam

#endif // STEAM_BLOCK_SPARSE_MATRIX_HPP
