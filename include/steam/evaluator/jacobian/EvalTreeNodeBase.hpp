//////////////////////////////////////////////////////////////////////////////////////////////
/// \file EvalTreeNodeBase.hpp
///
/// \author Sean Anderson, ASRL
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef STEAM_EVAL_TREE_NODE_BASE_HPP
#define STEAM_EVAL_TREE_NODE_BASE_HPP

#include <vector>
#include <steam/evaluator/jacobian/Jacobian.hpp>

namespace steam {

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Simple structure to hold Jacobian information
//////////////////////////////////////////////////////////////////////////////////////////////
class EvalTreeNodeBase
{
 public:

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Default constructor
  //////////////////////////////////////////////////////////////////////////////////////////////
  EvalTreeNodeBase();

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Destructor
  //////////////////////////////////////////////////////////////////////////////////////////////
  virtual ~EvalTreeNodeBase();

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Use when node was allocated using a pool. This function causes the object to
  ///        release itself back to the pool it was allocated from. While the user is
  ///        responsible for releasing the top level node, this interface method is required
  ///        in order for this node to release its children.
  //////////////////////////////////////////////////////////////////////////////////////////////
  virtual void release() = 0;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Release children and reset internal indexing to zero.
  //////////////////////////////////////////////////////////////////////////////////////////////
  virtual void reset();

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Add child evaluation node (order of addition is preserved)
  //////////////////////////////////////////////////////////////////////////////////////////////
  void addChild(EvalTreeNodeBase* newChild);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Get number of child evaluation nodes
  //////////////////////////////////////////////////////////////////////////////////////////////
  size_t numChildren() const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Get child node at index
  //////////////////////////////////////////////////////////////////////////////////////////////
  EvalTreeNodeBase* childAt(unsigned int index) const;

 protected:

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Children nodes
  //////////////////////////////////////////////////////////////////////////////////////////////
  EvalTreeNodeBase* children_[4];
  unsigned int index_;

};

} // steam

#endif // STEAM_EVAL_TREE_NODE_BASE_HPP
