//////////////////////////////////////////////////////////////////////////////////////////////
/// \file CostTerm.hpp
///
/// \author Sean Anderson, ASRL
//////////////////////////////////////////////////////////////////////////////////////////////

#ifndef STEAM_COST_TERM_HPP
#define STEAM_COST_TERM_HPP

#include <boost/shared_ptr.hpp>

#include <steam/evaluator/ErrorEvaluator.hpp>
#include <steam/problem/NoiseModel.hpp>
#include <steam/problem/LossFunctions.hpp>

namespace steam {

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Class that fully defines a nonlinear cost term (or 'factor').
///        Cost terms are composed of an error function, loss function and noise model.
//////////////////////////////////////////////////////////////////////////////////////////////
template<int MEAS_DIM, int MAX_STATE_SIZE>
class CostTerm
{
public:

  /// Convenience typedefs
  typedef boost::shared_ptr<CostTerm<MEAS_DIM,MAX_STATE_SIZE> > Ptr;
  typedef boost::shared_ptr<const CostTerm<MEAS_DIM,MAX_STATE_SIZE> > ConstPtr;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Constructor
  //////////////////////////////////////////////////////////////////////////////////////////////
  CostTerm(const typename ErrorEvaluator<MEAS_DIM,MAX_STATE_SIZE>::ConstPtr& errorFunction,
           const typename NoiseModel<MEAS_DIM>::ConstPtr& noiseModel,
           const LossFunction::ConstPtr& lossFunc);

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Evaluate the cost of this term. Error is first whitened by the noise model
  ///        and then passed through the loss function, as in:
  ///          cost = loss(sqrt(e^T * cov^{-1} * e))
  //////////////////////////////////////////////////////////////////////////////////////////////
  double evaluate() const;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Evaluate the iteratively reweighted error vector and Jacobians. The error and
  ///        Jacobians are first whitened by the noise model and then weighted by the loss
  ///        function, as in:
  ///              error = sqrt(weight)*sqrt(cov^-1)*rawError
  ///           jacobian = sqrt(weight)*sqrt(cov^-1)*rawJacobian
  //////////////////////////////////////////////////////////////////////////////////////////////
  Eigen::Matrix<double,MEAS_DIM,1> evalWeightedAndWhitened(
      std::vector<Jacobian<MEAS_DIM,MAX_STATE_SIZE> >* outJacobians) const;

private:

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Error evaluator
  //////////////////////////////////////////////////////////////////////////////////////////////
  typename ErrorEvaluator<MEAS_DIM,MAX_STATE_SIZE>::ConstPtr errorFunction_;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Noise model
  //////////////////////////////////////////////////////////////////////////////////////////////
  typename NoiseModel<MEAS_DIM>::ConstPtr noiseModel_;

  //////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief Loss function
  //////////////////////////////////////////////////////////////////////////////////////////////
  LossFunction::ConstPtr lossFunc_;
};

//////////////////////////////////////////////////////////////////////////////////////////////
/// \brief Typedef for the general dynamic cost term
//////////////////////////////////////////////////////////////////////////////////////////////
typedef CostTerm<Eigen::Dynamic, Eigen::Dynamic> CostTermX;

} // steam

#include <steam/problem/CostTerm-inl.hpp>

#endif // STEAM_COST_TERM_HPP
